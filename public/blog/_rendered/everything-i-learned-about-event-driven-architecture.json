{
  "meta": {
    "slug": "everything-i-learned-about-event-driven-architecture",
    "title": "Everything I Learned About Event-Driven Architecture",
    "description": "The patterns, the pitfalls, the diagrams nobody showed me, and the 2 AM lessons that changed how I build software.",
    "date": "2026-01-31",
    "link": "https://shushankrecentendeavors.substack.com/p/everything-i-learned-about-event",
    "creator": "Shushank recent endeavors",
    "tags": [],
    "readTime": "16 min read",
    "coverImage": ""
  },
  "content": "<p>There was a time I thought building software was mostly about writing clean functions and making sure the frontend didnâ€™t blow up. Then I worked on a system that needed to coordinate 40+ micro-services in real-time, and my beautiful request-response world shattered into a million pieces.</p><p>Thatâ€™s when I discovered Event-Driven Architecture (EDA). Itâ€™s not just a buzzword â€” itâ€™s a fundamentally different way of thinking about how software communicates. And after going deep into it, I want to share everything: the mental models, the patterns drawn out, the painful lessons, and the stuff I wish someone had sketched on a whiteboard for me on day one.</p><div class=\"subscription-widget-wrap-editor\" data-attrs=\"{&quot;url&quot;:&quot;https://shushankrecentendeavors.substack.com/subscribe?&quot;,&quot;text&quot;:&quot;Subscribe&quot;,&quot;language&quot;:&quot;en&quot;}\" data-component-name=\"SubscribeWidgetToDOM\"><div class=\"subscription-widget show-subscribe\"><div class=\"preamble\"><p class=\"cta-caption\">Thanks for reading! Subscribe for free to receive new posts and support my work.</p></div><form class=\"subscription-widget-subscribe\"><input type=\"email\" class=\"email-input\" name=\"email\" placeholder=\"Type your emailâ€¦\" tabindex=\"-1\"><input type=\"submit\" class=\"button primary\" value=\"Subscribe\"><div class=\"fake-input-wrapper\"><div class=\"fake-input\"></div><div class=\"fake-button\"></div></div></form></div></div><p>Some quick numbers to set the stage:</p><ul><li><p><strong>72%</strong> of global organizations now use some form of EDA</p></li><li><p><strong>66 million messages/sec</strong> â€” Shopifyâ€™s peak Kafka throughput</p></li><li><p><strong>2,300+ microservices</strong> â€” what Wix runs on event-driven infrastructure</p></li><li><p><strong>90%</strong> of the worldâ€™s largest companies will use real-time data by 2025 (IDC)</p></li></ul><p>This isnâ€™t niche anymore. Letâ€™s get into it.</p><div><hr></div><h2>Chapter 1: Wait â€” What Even Is an â€œEventâ€?</h2><p>This tripped me up for months. An event is <strong>not</strong> a command. Itâ€™s not â€œhey, go do this thing.â€ An event is a <strong>record of something that already happened</strong>. Past tense. Itâ€™s a fact.</p><pre><code><code>  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚     âœ• COMMANDS (NOT EVENTS)     â”‚     â”‚        âœ“ EVENTS (FACTS)         â”‚\n  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚\n  â”‚                                 â”‚     â”‚                                 â”‚\n  â”‚  \"Create this order\"            â”‚     â”‚  OrderPlaced                    â”‚\n  â”‚  \"Send this email\"              â”‚     â”‚  PaymentReceived                â”‚\n  â”‚  \"Reserve this inventory\"       â”‚     â”‚  UserEmailChanged               â”‚\n  â”‚                                 â”‚     â”‚                                 â”‚\n  â”‚  â†’ tells someone WHAT TO DO     â”‚     â”‚  â†’ announces WHAT HAPPENED      â”‚\n  â”‚    (imperative, coupled)        â”‚     â”‚    (declarative, decoupled)     â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n</code></code></pre><p>This distinction changes everything. When services produce facts instead of instructions, they stop being bossy controllers and start being humble reporters. Consumers observe and decide for themselves how to react. The producer doesnâ€™t even know consumers exist.</p><p>Every event has two parts: a <strong>header</strong> (name, timestamp, unique ID, type) and a <strong>payload</strong> (the data about what changed). Getting the payload design right is one of the hardest parts of EDA â€” weâ€™ll come back to this.</p><div><hr></div><h2>Chapter 2: Why Request-Response Started Falling Apart</h2><p>I grew up on request-response. Service A calls Service B, waits for a response, then calls Service C. Clean. Linear. Debuggable. I loved it â€” until the system scaled.</p><p>Hereâ€™s what happens when one service in a synchronous chain goes down:</p><pre><code><code>  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    WAIT    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    WAIT    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    WAIT    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ Order Svc â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt;â”‚Payment Svcâ”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt;â”‚Inventory  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt;â”‚ Email Svcâ”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                                 â”‚\n                                 â–¼\n                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                          â”‚  ğŸ’¥ DOWN    â”‚\n                          â”‚ (deploying) â”‚\n                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                                 â”‚\n            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n            â–¼                    â–¼                     â–¼\n    Order Svc STUCK      Inventory STUCK        Email STUCK\n\n    &gt;&gt;&gt; One service dies â†’ everything waiting on it breaks &lt;&lt;&lt;\n    &gt;&gt;&gt; This is \"temporal coupling\" â€” both sides must be alive simultaneously &lt;&lt;&lt;\n</code></code></pre><p>This isnâ€™t theoretical. Iâ€™ve watched a payment service deploy take down the entire order flow for 30 seconds. In e-commerce, 30 seconds is an eternity.</p><p>Event-Driven Architecture flips this completely. Instead of â€œcall and wait,â€ itâ€™s â€œannounce and move onâ€:</p><pre><code><code>                                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                                               â”Œâ”€â”€â”€&gt;â”‚ ğŸ’³ Payment   â”‚\n                                               â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”¤    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ Order Serviceâ”‚â”€â”€â”€&gt;â”‚ OrderPlaced  â”‚â”€â”€â”€&gt;â”‚    â”œâ”€â”€â”€&gt;â”‚ ğŸ“¦ Inventory â”‚\n  â”‚  (producer)  â”‚    â”‚   (event)    â”‚    â”‚ B  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ R  â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                                          â”‚ O  â”œâ”€â”€â”€&gt;â”‚ ğŸ“§ Email     â”‚\n    doesn't know                          â”‚ K  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n    or care who's                         â”‚ E  â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    listening                             â”‚ R  â”œâ”€â”€â”€&gt;â”‚ ğŸ“Š Analytics â”‚\n                                          â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                                                    â”Œ â”€ â”€ â”€ â”€ â”€ â”€ â”\n                                                       Future Svc?\n                                                    â”‚ just subscribeâ”‚\n                                                    â”” â”€ â”€ â”€ â”€ â”€ â”€ â”˜\n</code></code></pre><p>The producer doesnâ€™t know â€” or care â€” whoâ€™s listening. If the Email Service is down, the event waits in the broker. No cascading failure. No timeout hell. It felt like going from mandatory synchronous meetings to async Slack messages. Things got done without everyone needing to be online at the same time.</p><div><hr></div><h2>Chapter 3: The Three Players</h2><p>Every event-driven system has three core components:</p><p><strong>ğŸ¤ Producers</strong> â€” Detect that something happened and publish an event. They have zero knowledge of whoâ€™s consuming. Shouting into the void â€” by design.</p><p><strong>ğŸ”€ Event Broker</strong> â€” The infrastructure in between. Handles routing, filtering, buffering, persistence. Kafka, RabbitMQ, Amazon SQS â€” all brokers with different trade-offs.</p><p><strong>ğŸ‘‚ Consumers</strong> â€” Listen for events they care about and react independently. Adding a new consumer = just subscribe. No changes to the producer needed.</p><p>The broker decouples producers from consumers in three ways:</p><ul><li><p><strong>Space</strong> â€” they donâ€™t need to know each other</p></li><li><p><strong>Time</strong> â€” they donâ€™t need to run simultaneously</p></li><li><p><strong>Interface</strong> â€” they donâ€™t share protocols beyond the event format</p></li></ul><p>This triple decoupling is the fundamental superpower of EDA.</p><div><hr></div><h2>Chapter 4: Broker vs. Mediator Topology</h2><p>Something I didnâ€™t learn until embarrassingly late: there are two fundamentally different ways to wire up an event-driven system.</p><pre><code><code>       CHOREOGRAPHY                              ORCHESTRATION\n       (Broker Topology)                         (Mediator Topology)\n\n       â”Œâ”€â”€â”€â”€â”€â”                                    â”Œâ”€â”€â”€â”€â”€â”\n       â”‚Svc Aâ”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€&gt;â”‚Svc Aâ”‚\n       â””â”€â”€â”¬â”€â”€â”˜          â”‚                    â”‚    â””â”€â”€â”€â”€â”€â”˜\n          â”‚          â”Œâ”€â”€â”€â”´â”€â”€â”           â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”\n          â–¼          â”‚Svc D â”‚           â”‚  Orch-  â”‚\n       â”Œâ”€â”€â”€â”€â”€â”       â””â”€â”€â”€â”€â”€â”€â”˜           â”‚ estratorâ”‚\n       â”‚Svc Bâ”‚â—„â”€â”€â”                      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜\n       â””â”€â”€â”¬â”€â”€â”˜   â”‚                      â”‚    â”‚    â”‚\n          â”‚   â”Œâ”€â”€â”´â”€â”€â”                   â”‚    â”‚    â”‚\n          â””â”€â”€&gt;â”‚Svc Câ”‚              â”Œâ”€â”€â”€â”€â”˜    â”‚    â””â”€â”€â”€â”€â”\n              â””â”€â”€â”€â”€â”€â”˜              â–¼         â–¼         â–¼\n                                â”Œâ”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”\n    Everyone reacts to          â”‚Svc Bâ”‚   â”‚Svc Câ”‚   â”‚Svc Dâ”‚\n    events they see             â””â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”˜\n\n                                   Central conductor\n                                   directs everything\n</code></code></pre><p><strong>Choreography</strong> â€” No central controller. Services publish and react independently. Maximum decoupling and scalability, but hard to trace end-to-end business flows. Logic gets scattered.</p><p><strong>Orchestration</strong> â€” A central orchestrator controls the workflow, telling each service what to do next. Better visibility, clearer error handling, but introduces a coordination bottleneck and tighter coupling.</p><p>In reality? <strong>Most systems use a hybrid.</strong> Simple parallel reactions (send email + update analytics) â†’ choreography. Complex business transactions (order â†’ reserve â†’ pay â†’ ship) â†’ orchestration. No shame in mixing.</p><div><hr></div><h2>Chapter 5: The Patterns That Actually Matter</h2><p>EDA isnâ€™t just â€œpublish event, consume event.â€ Here are the patterns Iâ€™ve actually used and learned about in depth, with the diagrams I wish Iâ€™d had earlier.</p><h3>ğŸ”” Publish / Subscribe</h3><p>The bread and butter. One event, many consumers, all independent.</p><pre><code><code>  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚              â”‚         â”‚           â”‚   â”Œâ”€â”€â”€&gt;â”‚ ğŸ’³ PaymentSvcâ”‚\n  â”‚ OrderService â”‚â”€â”€â”€â”€â”€â”€â”€â”€&gt;â”‚   Topic   â”‚â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n  â”‚  (producer)  â”‚  event  â”‚\"orders\"   â”‚   â”œâ”€â”€â”€&gt;â”‚ ğŸ“¦ Inventory â”‚\n  â”‚              â”‚         â”‚           â”‚   â”œâ”€â”€â”€&gt;â”‚ ğŸ“§ EmailSvc  â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€&gt;â”‚ ğŸ“Š Analytics â”‚\n                                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                                                â”Œ â”€ â”€ â”€ â”€ â”€ â”€ â”€â”\n                                                  New consumer?\n                                                â”‚ Just subscribe.â”‚\n                                                  Zero changes\n                                                â”‚ to producer.   â”‚\n                                                â”” â”€ â”€ â”€ â”€ â”€ â”€ â”€â”˜\n</code></code></pre><p>This is where the open/closed principle really shines at the architecture level. The system is <em>open for extension</em> (new consumer) and <em>closed for modification</em> (producer never changes).</p><h3>â³ Event Streaming</h3><p>If Pub/Sub is â€œbroadcast and forget,â€ event streaming is â€œbroadcast and remember.â€ The key difference: <strong>events are persisted in an ordered, immutable log</strong> that consumers can replay from any point.</p><pre><code><code>  Producer writes to an append-only log:\n\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚  Partition 0                                       â”‚\n  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€ â”€ â”€ â”‚\n  â”‚  â”‚ ev.0 â”‚ ev.1 â”‚ ev.2 â”‚ ev.3 â”‚ ev.4 â”‚ ev.5 â”‚      â”‚\n  â”‚  â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€ â”€ â”€ â”‚\n  â”‚                    â–²              â–²                 â”‚\n  â”‚                    â”‚              â”‚                 â”‚\n  â”‚              Consumer A     Consumer B              â”‚\n  â”‚              (offset: 2)   (offset: 4)             â”‚\n  â”‚                                                    â”‚\n  â”‚  Each consumer tracks its own position (offset).   â”‚\n  â”‚  Can rewind, replay, or read at its own pace.      â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n</code></code></pre><p>This is the model Apache Kafka popularized (born at LinkedIn, now ubiquitous). Unlike traditional message queues where messages disappear after consumption, Kafka retains events for a configurable period â€” days, weeks, or forever.</p><p>This enables some powerful things: new consumers can replay history from the beginning, you can reprocess data after fixing a bug, and you have a built-in audit trail.</p><h3>ğŸ“œ Event Sourcing</h3><p>Instead of storing <em>current state</em> (balance: $535), you store <strong>every event that led there</strong>. Think bank statement vs. bank balance.</p><pre><code><code>  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚   TRADITIONAL (CRUD)    â”‚         â”‚       EVENT SOURCED              â”‚\n  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚\n  â”‚                         â”‚         â”‚                                  â”‚\n  â”‚  accounts table         â”‚         â”‚  event store (append only)       â”‚\n  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚\n  â”‚  â”‚ id: acct_001      â”‚  â”‚         â”‚  â”‚ 1. AccountCreated    +$100 â”‚  â”‚\n  â”‚  â”‚ balance: $535      â”‚  â”‚         â”‚  â”‚ 2. StatusActivated         â”‚  â”‚\n  â”‚  â”‚ status: active     â”‚  â”‚         â”‚  â”‚ 3. FundsDeposited    +$500 â”‚  â”‚\n  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚         â”‚  â”‚ 4. FundsWithdrawn     -$45 â”‚  â”‚\n  â”‚                         â”‚         â”‚  â”‚ 5. FundsWithdrawn     -$20 â”‚  â”‚\n  â”‚  âŒ HOW did it get      â”‚         â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚\n  â”‚     to $535?            â”‚         â”‚  â”‚ Replay all = $535 âœ“        â”‚  â”‚\n  â”‚     We'll never know.   â”‚         â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚\n  â”‚     History is lost.    â”‚         â”‚                                  â”‚\n  â”‚                         â”‚         â”‚  âœ… Full history. Time travel.   â”‚\n  â”‚                         â”‚         â”‚     Audit log for free.          â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n</code></code></pre><p>Event sourcing gives you a complete audit trail, the ability to reconstruct state at any point in time, and the power to derive entirely new read models from historical events.</p><blockquote><p><strong>âš ï¸ Real talk:</strong> Event sourcing is intellectually beautiful but <strong>operationally complex</strong>. Replaying millions of events is slow (youâ€™ll need snapshots). Schema evolution of old events is brutal. Wix, running 2,300+ microservices on EDA, explicitly noted that event sourcing was too complex for most of their use cases. <strong>Reserve it for domains that genuinely need it</strong> â€” finance, compliance, collaborative editing.</p></blockquote><h3>âš¡ CQRS â€” Command Query Responsibility Segregation</h3><p>Separate the model that handles writes from the model that handles reads. Because they have fundamentally different needs.</p><pre><code><code>                          WRITE PATH (Commands)\n                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n               â”Œâ”€â”€â”€&gt;â”‚ Command â”‚â”€â”€â”€&gt;â”‚Write Modelâ”‚â”€â”€â”€&gt;â”‚ Write DB â”‚\n               â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚(validates)â”‚    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚\n  â”‚ Client â”‚â”€â”€â”€â”¤                                    Event published\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                                         â”‚\n               â”‚                                         â–¼\n               â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n               â””â”€â”€â”€&gt;â”‚  Query  â”‚â”€â”€â”€&gt;â”‚Read Model â”‚â—„â”€â”€â”€â”‚ Read DB  â”‚\n                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚(optimized)â”‚    â”‚(replicas)â”‚\n                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                          READ PATH (Queries)\n\n  Write DB â†’ optimized for consistency, validation\n  Read DB  â†’ optimized for fast queries, can have 5x replicas\n  Trade-off: Read model is eventually consistent (usually ms behind)\n</code></code></pre><p>Why bother? Because in most systems, reads outnumber writes 10:1 or 100:1. With CQRS, you can scale them independently, optimize each data store for its job, and even use different technologies (SQL for writes, Elasticsearch for reads, for example).</p><p>The trade-off is eventual consistency â€” the read model is always slightly behind the write model. Usually milliseconds, but your UX needs to account for this.</p><h3>ğŸ”— The Saga Pattern</h3><p>Distributed transactions across multiple services. Instead of one giant database transaction, break it into a chain of local transactions with compensating actions if things fail.</p><pre><code><code>  HAPPY PATH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt;\n\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ 1. Create  â”‚â”€â”€â”€&gt;â”‚ 2. Reserve â”‚â”€â”€â”€&gt;â”‚ 3. Reserve â”‚â”€â”€â”€&gt;â”‚ 4. Process â”‚â”€â”€â”€&gt;â”‚ âœ… Order  â”‚\n  â”‚   Order    â”‚    â”‚   Credit   â”‚    â”‚  Inventory â”‚    â”‚  Payment   â”‚    â”‚  APPROVED â”‚\n  â”‚ (PENDING)  â”‚    â”‚     âœ“      â”‚    â”‚     âœ“      â”‚    â”‚     âœ“      â”‚    â”‚           â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n  WHAT IF STEP 3 FAILS? â—„â”€â”€ COMPENSATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ Undo Stp 1 â”‚â—„â”€â”€â”€â”‚ Undo Stp 2 â”‚â—„â”€â”€â”€â”‚ ğŸ’¥ Step 3  â”‚\n  â”‚Cancel Orderâ”‚    â”‚Release Credâ”‚    â”‚   FAILED   â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n  Each step = local transaction.\n  Failure triggers compensating transactions backwards.\n</code></code></pre><p>The saga pattern comes in two flavors:</p><ul><li><p><strong>Choreography saga</strong> â€” each service publishes an event after its local transaction, and the next service reacts. Simpler, more decoupled, but hard to track.</p></li><li><p><strong>Orchestration saga</strong> â€” a central orchestrator tells each service what to do, step by step. More visible and easier to manage complex flows.</p></li></ul><p>For anything with more than 3â€“4 steps, Iâ€™ve found orchestration sagas much easier to reason about and debug.</p><h3>ğŸ“® The Transactional Outbox Pattern</h3><p>This solves the <strong>dual-write problem</strong> â€” the most insidious bug in event-driven systems. You need to update your DB AND publish an event. If one fails and the other succeeds, your system is silently inconsistent.</p><pre><code><code>  âŒ THE PROBLEM                          âœ… THE OUTBOX SOLUTION\n  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ Service â”‚                              â”‚ Service â”‚\n  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜\n       â”‚                                        â”‚\n       â”‚  1. Save to DB âœ“                       â”‚  1. Single DB transaction:\n       â”‚  2. Publish to Kafka...                â”‚     - Save business data\n       â”‚                                        â”‚     - Write event to \"outbox\" table\n       â–¼                    â–¼                   â”‚\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â–¼\n  â”‚   DB    â”‚        â”‚  Kafka   â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ updated â”‚        â”‚  ğŸ’¥ FAIL â”‚          â”‚     SAME DB TX       â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”‚\n                                           â”‚  â”‚ Data â”‚ â”‚Outbox â”‚ â”‚\n  DB has the data,                         â”‚  â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”˜ â”‚\n  but nobody knows!                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”˜\n  Silent inconsistency.                                    â”‚\n                                                           â–¼\n                                                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                                                   â”‚ CDC / Relay  â”‚\n                                                   â”‚ (Debezium)   â”‚\n                                                   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜\n                                                          â”‚\n                                                          â–¼\n                                                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                                                   â”‚    Kafka     â”‚\n                                                   â”‚  âœ… reliable â”‚\n                                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n</code></code></pre><p>Both the business data and the event record are written in <strong>one</strong> database transaction â€” guaranteed atomic. A CDC (Change Data Capture) connector like Debezium then tails the outbox table and reliably publishes the events to Kafka.</p><blockquote><p><strong>ğŸ”¥ Lesson learned at 2 AM:</strong> The dual-write problem seems theoretical until it eats your production data. Implement the outbox pattern from day one. Donâ€™t negotiate with this one.</p></blockquote><h3>ğŸ”„ Event-Carried State Transfer (ECST)</h3><p>Instead of consumers calling back to the producer to fetch data they need, the event carries enough state that consumers can act independently.</p><pre><code><code>  Skinny event (bad):                    Fat-enough event (good):\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ OrderPlaced          â”‚               â”‚ OrderPlaced                â”‚\n  â”‚ { orderId: \"abc\" }  â”‚               â”‚ { orderId: \"abc\",          â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚   userId: \"u123\",          â”‚\n            â”‚                            â”‚   items: [...],            â”‚\n            â–¼                            â”‚   total: 99.50,            â”‚\n  Consumer must call back:               â”‚   shippingAddr: {...} }    â”‚\n  \"What's in order abc?\"                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â†’ coupling!                                         â”‚\n  â†’ latency!                                          â–¼\n  â†’ what if Order Svc                    Consumer has everything\n    is down?                             it needs. Fully decoupled.\n</code></code></pre><p>The trade-off is bigger messages and some data duplication. But in my experience, the autonomy and resilience you gain far outweigh the storage cost. The key is finding the right balance â€” include what consumers need, not everything you have.</p><div><hr></div><h2>Chapter 6: Kafka vs. RabbitMQ â€” The Real Comparison</h2><p>Iâ€™ve used both. Hereâ€™s the honest breakdown:</p><p><strong>Apache KafkaRabbitMQMental model</strong>Distributed immutable logSmart message broker/router<strong>Delivery</strong>Pull-based (consumers poll)Push-based (broker pushes)<strong>Retention</strong>âœ… Persists events (days/weeks/forever)âŒ Deletes after consumption<strong>Replay</strong>âœ… Consumers can rewind offsetâŒ Not natively<strong>Throughput</strong>Millions/sec on modest hardwareTens of thousands/sec<strong>Routing</strong>Simple (topic + partitions)âœ… Sophisticated (exchanges, bindings, headers)<strong>Protocols</strong>Custom binary over TCPâœ… AMQP, MQTT, STOMP<strong>Learning curve</strong>Steep (partitions, offsets, replication)Gentler (queues, exchanges, bindings)<strong>Best for</strong>Event streaming, data pipelines, sourcingTask queues, flexible routing, transactional</p><p><strong>When to pick Kafka:</strong> You need event replay, high throughput, or event sourcing. Youâ€™re building data pipelines or stream processing. Uber uses Kafka + Apache Flink for pricing, fraud detection, and trip monitoring across petabytes of real-time data.</p><p><strong>When to pick RabbitMQ:</strong> You need sophisticated routing logic, protocol flexibility, or traditional task queues. You want something that â€œjust worksâ€ quickly. DoorDash noted they barely spent time learning RabbitMQ and it handled their hyper-growth smoothly.</p><p><strong>The honest answer:</strong> Many organizations use <strong>both</strong>. Kafka for event streaming and data pipelines. RabbitMQ for transactional messaging and task queues. This hybrid is more common than the internet flame wars suggest.</p><div><hr></div><h2>Chapter 7: The Hard Parts Nobody Warns You About</h2><p>Let me be brutally honest about where EDA bites you.</p><pre><code><code>                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n               â”Œâ”€â”€â”€â”€â”€â”€â”€&gt;â”‚  ğŸ› Debugging    â”‚\n               â”‚        â”‚  across 8 async  â”‚\n               â”‚        â”‚  services        â”‚\n               â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚   ğŸœ Event    â”‚     â”‚  â± Eventual      â”‚\n  â”‚   Soup        â”‚â—„â”€â”€â”€â”€â”¤  Consistency     â”‚\n  â”‚   (100s of    â”‚     â”‚  (read lag)      â”‚\n  â”‚   events,     â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â”‚   no trace)   â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”˜            EVENT\n               â”‚              DRIVEN\n               â”‚            ARCHITECTURE\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”\n  â”‚  ğŸ“Š Message   â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚  Ordering     â”‚â”€â”€â”€â”€&gt;â”‚  ğŸ“‹ Schema       â”‚\n  â”‚  (Cancel      â”‚     â”‚  Evolution       â”‚\n  â”‚  before       â”‚     â”‚  (15 consumers   â”‚\n  â”‚  Place?!)     â”‚     â”‚  depend on it)   â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n               â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n               â””â”€â”€â”€â”€â”€â”€â”€&gt;â”‚  ğŸ” Idempotency  â”‚\n                        â”‚  (dupes WILL     â”‚\n                        â”‚  happen)         â”‚\n                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n</code></code></pre><h3>ğŸ› Debugging Is a Different Beast</h3><p>In request-response, you trace a call stack. In EDA, one event triggers 8 services which trigger more events which trigger more services. Without <strong>distributed tracing</strong> (OpenTelemetry, Jaeger, Datadog) and <strong>correlation IDs</strong> propagated through every single event, youâ€™re flying blind.</p><p>Set up observability <em>before</em> production. After your first incident is too late.</p><h3>â± Eventual Consistency Is a Team Sport</h3><p>Thereâ€™s always a delay between a write happening and all read models catching up. This isnâ€™t just a backend problem â€” your <strong>product managers and UX designers</strong> need to understand it. Build UIs with optimistic updates, loading states, and graceful staleness handling. â€œYour order is being processedâ€ is a perfectly valid UX pattern.</p><h3>ğŸ“‹ Schema Evolution Is Surgery on a Moving Train</h3><p>Once 15 consumers depend on an event format, changing it is terrifying. Use a <strong>schema registry</strong> (like Confluent Schema Registry) from day one. Follow backward-compatible evolution rules:</p><ul><li><p>Adding optional fields â†’ safe</p></li><li><p>Renaming or removing fields â†’ <strong>breaking</strong></p></li><li><p>Version events when you must make breaking changes (<code>OrderPlaced.v2</code>)</p></li></ul><h3>ğŸ” Idempotency Is Non-Negotiable</h3><p>Events <strong>will</strong> be delivered more than once. Network hiccup, consumer crash, broker retry â€” duplicates are inevitable. This is â€œat-least-onceâ€ delivery, and itâ€™s the default in most systems.</p><p>Every consumer must handle the same event twice without double-charging, double-emailing, or double-anything. Use unique event IDs + deduplication logic + upserts over inserts.</p><h3>ğŸ“Š Ordering Requires Thought</h3><p>Events within a Kafka partition are ordered. Across partitions, they are not. You must partition by the smallest unit that needs ordering â€” usually your domain aggregate (e.g., <code>orderId</code>, <code>userId</code>).</p><p>If you donâ€™t think about this, <code>OrderCanceled</code> might arrive <em>before</em> <code>OrderPlaced</code>. Yeah, thatâ€™s a fun one to debug.</p><h3>ğŸœ The â€œEvent Soupâ€ Anti-Pattern</h3><p>Hundreds of event types flying around, no documentation, no schema governance, consumers subscribing to events they donâ€™t fully understand, and nobody can trace the full lifecycle of a business process. Iâ€™ve seen it. Itâ€™s miserable.</p><p>Prevent it with event catalogs, clear ownership per event type, and regular pruning of unused events.</p><div><hr></div><h2>Chapter 8: When NOT to Use Event-Driven Architecture</h2><p>This might be the most valuable section. EDA is the wrong tool when:</p><p><strong>ğŸ”¨ Your system is simple.</strong> A handful of services with straightforward request-response interactions? REST + retry logic + circuit breakers. Donâ€™t buy a semi-truck to deliver groceries.</p><p><strong>âš¡ You need instant responses.</strong> User checks their bank balance and needs it NOW? Thatâ€™s a synchronous query. Forcing it through async adds unnecessary latency and complexity.</p><p><strong>ğŸŒŸ Because itâ€™s trendy.</strong> Setting up Kafka for 100 requests/minute is massive overkill. The operational complexity is real and constant â€” ZooKeeper (or KRaft), partition management, consumer groups, offset tracking, monitoring.</p><p><strong>ğŸ” You donâ€™t have observability yet.</strong> If you canâ€™t trace requests in your current synchronous system, adding asynchronous event flows will make debugging 10x harder, not 10x better.</p><blockquote><p>Start synchronous. Go async when you <em>feel the pain</em>. Itâ€™s much easier to migrate from a well-structured sync system to event-driven than the other way around.</p></blockquote><div><hr></div><h2>Chapter 9: What Iâ€™d Tell My Past Self</h2><p><strong>1. Start with the WHY, not the HOW.</strong> Donâ€™t start by picking Kafka. Start by identifying which parts of your system suffer from coupling, which need to scale independently, and where failures cascade. Let the problems guide the patterns.</p><p><strong>2. Get event design right.</strong> Spend more time on event naming, payload structure, and schema evolution strategy than on picking the perfect broker. The broker can be swapped. A badly designed event that 20 services depend on is a prison.</p><p><strong>3. Implement the outbox pattern from day one.</strong> Donâ€™t convince yourself the dual-write problem wonâ€™t happen to you. It will. At 2 AM. On a Friday.</p><p><strong>4. Invest in observability early.</strong> Correlation IDs, distributed tracing, consumer lag monitoring, dead letter queues. Set these up before you deploy, not after your first incident.</p><p><strong>5. Not every use case needs event sourcing.</strong> CDC + outbox gives you 80% of the benefits with 20% of the complexity. Save event sourcing for domains that genuinely need temporal queries and full audit trails.</p><p><strong>6. Embrace hybrid architectures.</strong> Synchronous within bounded contexts. Events between them. Choreography for simple parallel reactions. Orchestration for complex sequential flows. Mix freely and without guilt.</p><p><strong>7. This is a strategic transformation, not a technical upgrade.</strong> EDA changes how teams communicate, how you design APIs, how you handle failures, and how you test. Get organizational buy-in and adopt incrementally â€” donâ€™t try to rewrite everything at once.</p><div><hr></div><h2>Final Thoughts</h2><p>Event-Driven Architecture isnâ€™t a silver bullet â€” but itâ€™s one of the most powerful tools in a modern architectâ€™s toolkit. What I appreciate most about it isnâ€™t Kafkaâ€™s throughput or RabbitMQâ€™s routing flexibility, but the <strong>mental model</strong> it encourages.</p><p>Thinking in events forces you to think about whatâ€™s <em>actually happening</em> in your domain. <code>OrderPlaced</code> is a clearer abstraction than <code>POST /api/orders â†’ 201</code>. It pushes you toward better domain modeling, cleaner service boundaries, and more explicit data contracts.</p><p>The complexity is real. The learning curve is steep. The pitfalls are numerous. But the systems that come out the other side â€” where you can add new capabilities by simply subscribing to existing events, where a service failure doesnâ€™t cascade, where you can replay history to recover from bugs â€” these systems are worth every ounce of investment.</p><p><strong>TL;DR â€”</strong> Start simple. Let pain guide adoption. Get event design right. Implement the outbox pattern. Set up tracing. And for the love of everything â€” donâ€™t use event sourcing unless you genuinely need it.</p><div><hr></div><p><em>If youâ€™ve made it this far â€” thanks for reading. These are lessons from building, breaking, and rebuilding event-driven systems. I hope they save you at least one 2 AM incident. ğŸŒ™</em></p><div class=\"subscription-widget-wrap-editor\" data-attrs=\"{&quot;url&quot;:&quot;https://shushankrecentendeavors.substack.com/subscribe?&quot;,&quot;text&quot;:&quot;Subscribe&quot;,&quot;language&quot;:&quot;en&quot;}\" data-component-name=\"SubscribeWidgetToDOM\"><div class=\"subscription-widget show-subscribe\"><div class=\"preamble\"><p class=\"cta-caption\">Thanks for reading! Subscribe for free to receive new posts and support my work.</p></div><form class=\"subscription-widget-subscribe\"><input type=\"email\" class=\"email-input\" name=\"email\" placeholder=\"Type your emailâ€¦\" tabindex=\"-1\"><input type=\"submit\" class=\"button primary\" value=\"Subscribe\"><div class=\"fake-input-wrapper\"><div class=\"fake-input\"></div><div class=\"fake-button\"></div></div></form></div></div>"
}