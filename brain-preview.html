<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brain → Transformer Animation Preview</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #050510; overflow: hidden; font-family: 'Courier New', monospace; }
    canvas { display: block; }
    #info {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #555;
      font-size: 12px;
      text-align: center;
      pointer-events: none;
      z-index: 10;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="info">Click + drag to orbit &middot; Scroll to zoom</div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ============================================================
    //  GLOBALS
    // ============================================================
    let scene, camera, renderer, controls, clock;

    // Particle pools
    const BRAIN_COUNT = 18000;
    const RAIN_COUNT = 600;
    const NUMBER_COUNT = 80;

    let brainParticles, brainPositionsBase;
    let rainParticles, rainStates;
    let numberSprites = [];
    let digitTextures = [];
    let transformerGroup;
    let transformerLayers = [];
    let outputParticles;
    let conversionPlane;

    // Layout Y positions
    const BRAIN_Y = 28;
    const CONVERT_Y = 10;
    const SERVER_TOP_Y = -4;
    const SERVER_BOTTOM_Y = -28;

    init();
    animate();

    // ============================================================
    //  INIT
    // ============================================================
    function init() {
      clock = new THREE.Clock();

      // Scene
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050510, 0.008);

      // Camera
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
      camera.position.set(35, 12, 55);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x050510);
      document.body.appendChild(renderer.domElement);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 5, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 20;
      controls.maxDistance = 120;
      controls.update();

      // Lighting (subtle)
      const ambient = new THREE.AmbientLight(0x222244, 0.5);
      scene.add(ambient);
      const point1 = new THREE.PointLight(0xFF6B6B, 1, 80);
      point1.position.set(0, BRAIN_Y, 10);
      scene.add(point1);
      const point2 = new THREE.PointLight(0x4ECDC4, 0.8, 60);
      point2.position.set(0, SERVER_TOP_Y, 10);
      scene.add(point2);

      // Build scene
      createBrain();
      createRainSystem();
      createDigitTextures();
      createNumberSprites();
      createConversionPlane();
      createTransformer();
      createOutputEffect();
      createLabels();

      window.addEventListener('resize', onResize);
    }

    // ============================================================
    //  NOISE UTILITIES (for anatomical cortical folds)
    // ============================================================
    function _noiseHash(ix, iy, iz) {
      let h = ix | 0;
      h = (Math.imul(h ^ 0x61c88647, 0x9e3779b9) + iy) | 0;
      h = (Math.imul(h ^ 0x61c88647, 0x9e3779b9) + iz) | 0;
      h = Math.imul(h ^ (h >>> 16), 0x85ebca6b);
      h = Math.imul(h ^ (h >>> 13), 0xc2b2ae35);
      return ((h ^ (h >>> 16)) & 0x7fffffff) / 0x7fffffff;
    }

    function _smootherstep(t) { return t * t * t * (t * (t * 6 - 15) + 10); }

    function valueNoise3D(x, y, z) {
      const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
      const fx = _smootherstep(x - ix), fy = _smootherstep(y - iy), fz = _smootherstep(z - iz);
      const mix = (a, b, t) => a + (b - a) * t;
      return mix(
        mix(
          mix(_noiseHash(ix, iy, iz), _noiseHash(ix+1, iy, iz), fx),
          mix(_noiseHash(ix, iy+1, iz), _noiseHash(ix+1, iy+1, iz), fx), fy),
        mix(
          mix(_noiseHash(ix, iy, iz+1), _noiseHash(ix+1, iy, iz+1), fx),
          mix(_noiseHash(ix, iy+1, iz+1), _noiseHash(ix+1, iy+1, iz+1), fx), fy),
        fz);
    }

    function fbm(x, y, z, octaves) {
      let v = 0, a = 1, f = 1, m = 0;
      for (let i = 0; i < octaves; i++) {
        v += valueNoise3D(x * f, y * f, z * f) * a;
        m += a; a *= 0.5; f *= 2.0;
      }
      return v / m;
    }

    function ridgeNoise(x, y, z, octaves) {
      let v = 0, a = 1, f = 1, m = 0;
      for (let i = 0; i < octaves; i++) {
        let n = valueNoise3D(x * f, y * f, z * f);
        n = 1.0 - Math.abs(n * 2 - 1);
        v += n * a;
        m += a; a *= 0.5; f *= 2.1;
      }
      return v / m;
    }

    // ============================================================
    //  BRAIN (anatomically detailed sand particle cloud)
    // ============================================================
    function createBrain() {
      const positions = new Float32Array(BRAIN_COUNT * 3);
      const colors = new Float32Array(BRAIN_COUNT * 3);
      const sizes = new Float32Array(BRAIN_COUNT);
      brainPositionsBase = new Float32Array(BRAIN_COUNT * 3);

      // Anatomical color palette
      const gyrusColor = new THREE.Color('#E8A0A0');
      const sulcusColor = new THREE.Color('#9E5060');
      const midColor1 = new THREE.Color('#D4878F');
      const midColor2 = new THREE.Color('#C07080');
      const cerebellumLight = new THREE.Color('#D09898');
      const cerebellumDark = new THREE.Color('#A87080');
      const brainstemColor = new THREE.Color('#C8A898');

      // Particle allocations
      const CEREBRUM = 14000;
      const CEREBELLUM = 3000;
      const BRAINSTEM = BRAIN_COUNT - CEREBRUM - CEREBELLUM;

      let idx = 0;
      const PHI = (1 + Math.sqrt(5)) / 2;

      // ======= CEREBRUM (main brain hemispheres) =======
      for (let i = 0; i < CEREBRUM; i++) {
        // Fibonacci sphere — uniform sampling on unit sphere
        const theta = Math.acos(1 - 2 * (i + 0.5) / CEREBRUM);
        const phi = 2 * Math.PI * i / PHI;
        const st = Math.sin(theta), ct = Math.cos(theta);
        const sp = Math.sin(phi), cp = Math.cos(phi);

        const nx = st * cp;
        const ny = ct;        // +1 top, -1 bottom
        const nz = st * sp;

        // --- Base brain shape (deformed sphere) ---
        let r = 1.0;

        // Flatten the base
        if (ny < -0.25) {
          r *= 1.0 - Math.pow((-ny - 0.25) / 0.75, 0.7) * 0.35;
        }

        // Slight top flattening (brains aren't perfectly round on top)
        if (ny > 0.85) {
          r *= 1.0 - (ny - 0.85) / 0.15 * 0.08;
        }

        // Frontal pole — slightly more prominent forward
        if (nz > 0.3 && ny > -0.3) {
          r *= 1.0 + (nz - 0.3) * 0.12 * (1 - Math.abs(ny));
        }

        // Temporal lobe bumps (lower sides, bulge outward)
        const absNx = Math.abs(nx);
        if (ny < 0.15 && ny > -0.55 && absNx > 0.35) {
          const tbump = Math.sin((ny + 0.55) / 0.7 * Math.PI) * 0.2;
          r *= 1.0 + tbump * (absNx - 0.35) / 0.65;
        }

        // Occipital pole (back of brain)
        if (nz < -0.5 && ny > -0.4 && ny < 0.4) {
          r *= 1.0 + (-nz - 0.5) * 0.15 * Math.max(0, 1 - Math.abs(ny) * 1.5);
        }

        // Scale to brain dimensions
        let x = nx * r * 9.5;
        let y = ny * r * 7;
        let z = nz * r * 8;

        // --- Longitudinal fissure (gap between hemispheres) ---
        const fissureW = 0.45 + fbm(y * 0.2, z * 0.2, 5, 3) * 0.3;
        const fissureZone = fissureW * 2.5;
        if (Math.abs(x) < fissureZone && ny > -0.35) {
          const sign = x >= 0 ? 1 : -1;
          const proximity = 1.0 - Math.min(1, Math.abs(x) / fissureZone);
          const depth = 2.0 * proximity * Math.max(0, ny + 0.5);
          x = sign * Math.max(Math.abs(x), fissureW * 2 + depth * 0.5);
        }

        // --- Central sulcus (divides frontal from parietal lobe) ---
        const csPos = nz * 0.5 + 0.3;
        const csDist = Math.abs(nz - csPos);
        if (csDist < 0.12 && absNx > 0.2 && ny > -0.15 && ny < 0.8) {
          const indent = (1 - csDist / 0.12) * 0.5;
          x *= 1 - indent * 0.06;
        }

        // --- Lateral (Sylvian) fissure (divides temporal from frontal/parietal) ---
        const sylvianY = -0.1 + nz * 0.08;
        if (absNx > 0.35 && Math.abs(ny - sylvianY) < 0.1 && ny > -0.4 && ny < 0.15) {
          const si = (1 - Math.abs(ny - sylvianY) / 0.1) * 0.4;
          const dirIn = nx > 0 ? -1 : 1;
          x += dirIn * si * 0.8;
        }

        // --- Parieto-occipital sulcus ---
        if (nz < -0.3 && ny > 0.1 && ny < 0.7) {
          const posDist = Math.abs(nz + 0.3 + ny * 0.3);
          if (posDist < 0.1) {
            const indent = (1 - posDist / 0.1) * 0.3;
            z *= 1 + indent * 0.05;
          }
        }

        // --- Cortical folds (gyri & sulci) via noise ---
        const hemiSeed = nx >= 0 ? 0 : 50;

        // Primary fold pattern — ridge noise creates sharp gyri
        const fold1 = ridgeNoise(
          nx * 2.8 + hemiSeed, ny * 3.2, nz * 2.8, 5
        );

        // Secondary detail layer
        const fold2 = fbm(
          nx * 5 + hemiSeed + 30, ny * 5.5, nz * 5, 4
        );

        // Tertiary micro-folds for realism
        const fold3 = fbm(
          nx * 9 + hemiSeed + 60, ny * 9, nz * 9, 3
        );

        const foldVal = fold1 * 0.55 + fold2 * 0.3 + fold3 * 0.15;
        const foldDisp = (foldVal - 0.5) * 2;

        // Fold strength: stronger on upper brain, weaker at base
        const foldStr = 0.5 * Math.max(0.3, Math.min(1, ny + 0.8));

        x += nx * foldDisp * foldStr * 2.0;
        y += ny * foldDisp * foldStr * 1.5;
        z += nz * foldDisp * foldStr * 1.8;

        // --- Depth variation (most particles on surface) ---
        const depthScale = Math.random() < 0.8
          ? (0.96 + Math.random() * 0.08)
          : (0.75 + Math.random() * 0.21);
        x *= depthScale;
        y *= depthScale;
        z *= depthScale;

        // Store position
        const i3 = idx * 3;
        positions[i3] = x;
        positions[i3 + 1] = y + BRAIN_Y;
        positions[i3 + 2] = z;
        brainPositionsBase[i3] = x;
        brainPositionsBase[i3 + 1] = y + BRAIN_Y;
        brainPositionsBase[i3 + 2] = z;

        // Color: lighter on gyri (ridges), darker in sulci (grooves)
        let col;
        if (foldVal < 0.32) col = sulcusColor;
        else if (foldVal < 0.48) col = midColor2;
        else if (foldVal < 0.62) col = midColor1;
        else col = gyrusColor;

        colors[i3]     = col.r + (Math.random() - 0.5) * 0.04;
        colors[i3 + 1] = col.g + (Math.random() - 0.5) * 0.04;
        colors[i3 + 2] = col.b + (Math.random() - 0.5) * 0.04;
        sizes[idx] = 0.11 + Math.random() * 0.09;
        idx++;
      }

      // ======= CEREBELLUM (tightly folded, back-bottom) =======
      const halfCB = Math.floor(CEREBELLUM / 2);
      for (let side = -1; side <= 1; side += 2) {
        const count = side === -1 ? halfCB : CEREBELLUM - halfCB;
        for (let i = 0; i < count; i++) {
          const theta = Math.acos(1 - 2 * (i + 0.5) / count);
          const phi = 2 * Math.PI * i / PHI;
          const lx = Math.sin(theta) * Math.cos(phi);
          const ly = Math.cos(theta);
          const lz = Math.sin(theta) * Math.sin(phi);

          // Oblate spheroid dimensions
          const crx = 3.5, cry = 2.8, crz = 3.2;

          // Tight horizontal folia (signature cerebellum texture)
          const folia = Math.sin(ly * 28 + lx * 2) * 0.06
                      + Math.sin(ly * 45 + lz * 3) * 0.03
                      + Math.sin(ly * 18) * 0.04;

          let cx = lx * crx * (1 + folia) + side * 3.2;
          let cy = ly * cry * (1 + folia) - 6;
          let cz = lz * crz * (1 + folia) - 4;

          // Depth variation
          const cd = Math.random() < 0.75
            ? (0.93 + Math.random() * 0.14)
            : (0.72 + Math.random() * 0.21);
          cx = side * 3.2 + (cx - side * 3.2) * cd;
          cy = -6 + (cy + 6) * cd;
          cz = -4 + (cz + 4) * cd;

          const i3 = idx * 3;
          positions[i3] = cx;
          positions[i3 + 1] = cy + BRAIN_Y;
          positions[i3 + 2] = cz;
          brainPositionsBase[i3] = cx;
          brainPositionsBase[i3 + 1] = cy + BRAIN_Y;
          brainPositionsBase[i3 + 2] = cz;

          const cbr = Math.random() < 0.5 ? cerebellumLight : cerebellumDark;
          colors[i3]     = cbr.r + (Math.random() - 0.5) * 0.04;
          colors[i3 + 1] = cbr.g + (Math.random() - 0.5) * 0.04;
          colors[i3 + 2] = cbr.b + (Math.random() - 0.5) * 0.04;
          sizes[idx] = 0.08 + Math.random() * 0.06;
          idx++;
        }
      }

      // ======= BRAINSTEM (tapered cylinder descending from base) =======
      for (let i = 0; i < BRAINSTEM; i++) {
        const t = i / BRAINSTEM;
        const angle = Math.random() * Math.PI * 2;
        const stemLen = 5;
        const topR = 1.8, botR = 0.9;
        const yy = -5.5 - t * stemLen;
        const rr = topR + (botR - topR) * t;
        const jitter = 0.85 + Math.random() * 0.3;

        const bump = Math.sin(yy * 4 + angle * 2) * 0.12;
        const bx = Math.cos(angle) * rr * jitter + bump;
        const by = yy;
        const bz = Math.sin(angle) * rr * jitter - 3;

        const i3 = idx * 3;
        positions[i3] = bx;
        positions[i3 + 1] = by + BRAIN_Y;
        positions[i3 + 2] = bz;
        brainPositionsBase[i3] = bx;
        brainPositionsBase[i3 + 1] = by + BRAIN_Y;
        brainPositionsBase[i3 + 2] = bz;

        colors[i3]     = brainstemColor.r + (Math.random() - 0.5) * 0.04;
        colors[i3 + 1] = brainstemColor.g + (Math.random() - 0.5) * 0.04;
        colors[i3 + 2] = brainstemColor.b + (Math.random() - 0.5) * 0.04;
        sizes[idx] = 0.09 + Math.random() * 0.06;
        idx++;
      }

      // Build geometry
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const mat = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.85,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      brainParticles = new THREE.Points(geo, mat);
      scene.add(brainParticles);
    }

    // ============================================================
    //  RAIN SYSTEM (falling sand particles)
    // ============================================================
    function createRainSystem() {
      const positions = new Float32Array(RAIN_COUNT * 3);
      const colors = new Float32Array(RAIN_COUNT * 3);

      rainStates = [];

      for (let i = 0; i < RAIN_COUNT; i++) {
        const i3 = i * 3;
        positions[i3] = 0;
        positions[i3 + 1] = -999; // hidden
        positions[i3 + 2] = 0;
        colors[i3] = 0.9;
        colors[i3 + 1] = 0.6;
        colors[i3 + 2] = 0.6;

        rainStates.push({
          active: false,
          velocity: 0,
          drift: [0, 0],
          phase: 'sand', // 'sand' | 'number' | 'absorbed'
        });
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      rainParticles = new THREE.Points(geo, mat);
      scene.add(rainParticles);
    }

    // ============================================================
    //  DIGIT TEXTURES
    // ============================================================
    function createDigitTextures() {
      for (let d = 0; d <= 9; d++) {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 64, 64);
        ctx.fillStyle = '#00FFAA';
        ctx.font = 'bold 44px Courier New, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#00FFAA';
        ctx.shadowBlur = 8;
        ctx.fillText(String(d), 32, 32);
        const tex = new THREE.CanvasTexture(canvas);
        tex.needsUpdate = true;
        digitTextures.push(tex);
      }
    }

    // ============================================================
    //  NUMBER SPRITES (falling digits)
    // ============================================================
    function createNumberSprites() {
      for (let i = 0; i < NUMBER_COUNT; i++) {
        const digit = Math.floor(Math.random() * 10);
        const mat = new THREE.SpriteMaterial({
          map: digitTextures[digit],
          transparent: true,
          opacity: 0,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        const sprite = new THREE.Sprite(mat);
        sprite.scale.set(1.2, 1.2, 1);
        sprite.position.set(0, -999, 0);
        sprite.userData = {
          active: false,
          velocity: 0,
          targetX: 0,
          digit: digit,
        };
        scene.add(sprite);
        numberSprites.push(sprite);
      }
    }

    // ============================================================
    //  CONVERSION PLANE (where sand → numbers)
    // ============================================================
    function createConversionPlane() {
      const geo = new THREE.PlaneGeometry(30, 0.3);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x00FFAA,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
      });
      conversionPlane = new THREE.Mesh(geo, mat);
      conversionPlane.position.set(0, CONVERT_Y, 0);
      conversionPlane.rotation.x = Math.PI / 2;
      scene.add(conversionPlane);

      // Glowing ring at conversion zone
      const ringGeo = new THREE.TorusGeometry(12, 0.08, 8, 64);
      const ringMat = new THREE.MeshBasicMaterial({
        color: 0x00FFAA,
        transparent: true,
        opacity: 0.25,
        blending: THREE.AdditiveBlending,
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.set(0, CONVERT_Y, 0);
      ring.rotation.x = Math.PI / 2;
      scene.add(ring);
    }

    // ============================================================
    //  TRANSFORMER / SERVER
    // ============================================================
    function createTransformer() {
      transformerGroup = new THREE.Group();

      const serverWidth = 14;
      const serverDepth = 8;
      const serverHeight = 22;
      const layerCount = 6;

      // Server housing (wireframe)
      const housingGeo = new THREE.BoxGeometry(serverWidth, serverHeight, serverDepth);
      const housingEdges = new THREE.EdgesGeometry(housingGeo);
      const housingLine = new THREE.LineSegments(housingEdges, new THREE.LineBasicMaterial({
        color: 0x1a3a4a,
        transparent: true,
        opacity: 0.6,
      }));
      housingLine.position.y = SERVER_TOP_Y - serverHeight / 2;
      transformerGroup.add(housingLine);

      // Semi-transparent housing fill
      const housingFill = new THREE.Mesh(housingGeo, new THREE.MeshBasicMaterial({
        color: 0x0a1520,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide,
      }));
      housingFill.position.copy(housingLine.position);
      transformerGroup.add(housingFill);

      // Transformer layers
      const layerLabels = ['INPUT EMBED', 'SELF-ATTENTION', 'FEED FORWARD', 'SELF-ATTENTION', 'FEED FORWARD', 'OUTPUT'];
      const layerColors = [0x4ECDC4, 0xFF6B6B, 0xA78BFA, 0xFF6B6B, 0xA78BFA, 0x4ECDC4];

      for (let i = 0; i < layerCount; i++) {
        const layerY = SERVER_TOP_Y - 2 - i * (serverHeight / layerCount) - 0.5;
        const lw = serverWidth - 2;
        const lh = serverHeight / layerCount - 1.2;
        const ld = serverDepth - 2;

        const layerGeo = new THREE.BoxGeometry(lw, lh, ld);
        const layerMat = new THREE.MeshBasicMaterial({
          color: layerColors[i],
          transparent: true,
          opacity: 0.08,
          blending: THREE.AdditiveBlending,
        });
        const layerMesh = new THREE.Mesh(layerGeo, layerMat);
        layerMesh.position.set(0, layerY, 0);
        transformerGroup.add(layerMesh);

        // Layer edges
        const layerEdges = new THREE.EdgesGeometry(layerGeo);
        const edgeLine = new THREE.LineSegments(layerEdges, new THREE.LineBasicMaterial({
          color: layerColors[i],
          transparent: true,
          opacity: 0.3,
        }));
        edgeLine.position.copy(layerMesh.position);
        transformerGroup.add(edgeLine);

        transformerLayers.push({
          mesh: layerMesh,
          edges: edgeLine,
          baseOpacity: 0.08,
          edgeBaseOpacity: 0.3,
          glow: 0,
          color: layerColors[i],
          y: layerY,
        });

        // Connectors between layers (vertical lines)
        if (i < layerCount - 1) {
          const nextY = SERVER_TOP_Y - 2 - (i + 1) * (serverHeight / layerCount) - 0.5;
          const connGeo = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-lw / 3, layerY - lh / 2, 0),
            new THREE.Vector3(-lw / 3, nextY + lh / 2, 0),
          ]);
          const connGeo2 = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, layerY - lh / 2, 0),
            new THREE.Vector3(0, nextY + lh / 2, 0),
          ]);
          const connGeo3 = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(lw / 3, layerY - lh / 2, 0),
            new THREE.Vector3(lw / 3, nextY + lh / 2, 0),
          ]);
          const connMat = new THREE.LineBasicMaterial({
            color: 0x1a4a5a,
            transparent: true,
            opacity: 0.3,
          });
          transformerGroup.add(new THREE.LineSegments(connGeo, connMat));
          transformerGroup.add(new THREE.LineSegments(connGeo2, connMat));
          transformerGroup.add(new THREE.LineSegments(connGeo3, connMat));
        }
      }

      // Input funnel lines (top of server)
      for (let a = 0; a < 8; a++) {
        const angle = (a / 8) * Math.PI * 2;
        const topX = Math.cos(angle) * 10;
        const topZ = Math.sin(angle) * 10;
        const funnelGeo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(topX, SERVER_TOP_Y + 2, topZ),
          new THREE.Vector3(topX * 0.3, SERVER_TOP_Y, topZ * 0.3),
        ]);
        const funnelMat = new THREE.LineBasicMaterial({
          color: 0x00FFAA,
          transparent: true,
          opacity: 0.1,
        });
        transformerGroup.add(new THREE.LineSegments(funnelGeo, funnelMat));
      }

      scene.add(transformerGroup);
    }

    // ============================================================
    //  OUTPUT EFFECT
    // ============================================================
    function createOutputEffect() {
      const count = 200;
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 5;
        positions[i3] = Math.cos(angle) * radius;
        positions[i3 + 1] = SERVER_BOTTOM_Y - 2 - Math.random() * 6;
        positions[i3 + 2] = Math.sin(angle) * radius;

        const g = 0.5 + Math.random() * 0.5;
        colors[i3] = 0.2;
        colors[i3 + 1] = g;
        colors[i3 + 2] = g * 0.8;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      outputParticles = new THREE.Points(geo, new THREE.PointsMaterial({
        size: 0.15,
        vertexColors: true,
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      }));
      scene.add(outputParticles);
    }

    // ============================================================
    //  TEXT LABELS
    // ============================================================
    function createLabels() {
      const labels = [
        { text: 'BIOLOGICAL NEURAL NETWORK', y: BRAIN_Y + 10, color: '#E8A0A0', size: 0.7 },
        { text: '// data extraction', y: CONVERT_Y + 2.5, color: '#00FFAA', size: 0.5 },
        { text: 'TRANSFORMER MODEL', y: SERVER_TOP_Y + 1, color: '#4ECDC4', size: 0.6 },
        { text: 'TRAINING...', y: SERVER_BOTTOM_Y - 1, color: '#A78BFA', size: 0.45 },
      ];

      labels.forEach(({ text, y, color, size }) => {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 512, 64);
        ctx.fillStyle = color;
        ctx.font = `bold 32px Courier New, monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = color;
        ctx.shadowBlur = 12;
        ctx.fillText(text, 256, 32);

        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({
          map: tex,
          transparent: true,
          opacity: 0.7,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        const sprite = new THREE.Sprite(mat);
        sprite.scale.set(text.length * size * 0.55, size * 1.2, 1);
        sprite.position.set(0, y, 12);
        scene.add(sprite);
      });
    }

    // ============================================================
    //  ANIMATION LOOP
    // ============================================================
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      updateBrain(elapsed);
      updateRain(dt, elapsed);
      updateNumbers(dt);
      updateTransformerGlow(elapsed);
      updateOutput(elapsed);
      updateConversionPlane(elapsed);

      controls.update();
      renderer.render(scene, camera);
    }

    // ---- Brain breathing ----
    function updateBrain(t) {
      const positions = brainParticles.geometry.attributes.position.array;
      const breathe = Math.sin(t * 0.8) * 0.15;

      for (let i = 0; i < BRAIN_COUNT; i++) {
        const i3 = i * 3;
        const bx = brainPositionsBase[i3];
        const by = brainPositionsBase[i3 + 1];
        const bz = brainPositionsBase[i3 + 2];

        // Gentle breathing (expand/contract)
        const dx = bx * breathe * 0.03;
        const dy = (by - BRAIN_Y) * breathe * 0.03;
        const dz = bz * breathe * 0.03;

        positions[i3] = bx + dx;
        positions[i3 + 1] = by + dy;
        positions[i3 + 2] = bz + dz;
      }
      brainParticles.geometry.attributes.position.needsUpdate = true;
    }

    // ---- Rain particles ----
    function updateRain(dt, elapsed) {
      const positions = rainParticles.geometry.attributes.position.array;
      const colors = rainParticles.geometry.attributes.color.array;
      const brainPos = brainParticles.geometry.attributes.position.array;

      // Spawn new rain particles
      const spawnRate = 8; // particles per frame
      let spawned = 0;
      for (let i = 0; i < RAIN_COUNT && spawned < spawnRate; i++) {
        if (!rainStates[i].active) {
          // Pick a random brain particle position
          const srcIdx = Math.floor(Math.random() * BRAIN_COUNT) * 3;
          const i3 = i * 3;

          positions[i3] = brainPos[srcIdx] + (Math.random() - 0.5) * 0.5;
          positions[i3 + 1] = brainPos[srcIdx + 1];
          positions[i3 + 2] = brainPos[srcIdx + 2] + (Math.random() - 0.5) * 0.5;

          // Start color: brain pink
          colors[i3] = 0.9;
          colors[i3 + 1] = 0.63;
          colors[i3 + 2] = 0.63;

          rainStates[i].active = true;
          rainStates[i].velocity = 0.5 + Math.random() * 1;
          rainStates[i].drift = [(Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3];
          rainStates[i].phase = 'sand';
          spawned++;
        }
      }

      // Update active rain particles
      for (let i = 0; i < RAIN_COUNT; i++) {
        if (!rainStates[i].active) continue;

        const i3 = i * 3;

        // Gravity acceleration
        rainStates[i].velocity += dt * 6;
        positions[i3 + 1] -= rainStates[i].velocity * dt;

        // Horizontal drift
        positions[i3] += rainStates[i].drift[0] * dt;
        positions[i3 + 2] += rainStates[i].drift[1] * dt;

        const y = positions[i3 + 1];

        // Color transition: pink → white → cyan as it falls
        const fallProgress = Math.max(0, Math.min(1, (BRAIN_Y - y) / (BRAIN_Y - CONVERT_Y)));

        if (fallProgress < 0.5) {
          // Pink → White
          const t = fallProgress * 2;
          colors[i3] = 0.9 + t * 0.1;
          colors[i3 + 1] = 0.63 + t * 0.37;
          colors[i3 + 2] = 0.63 + t * 0.37;
        } else {
          // White → Cyan/Green
          const t = (fallProgress - 0.5) * 2;
          colors[i3] = 1.0 - t * 1.0;
          colors[i3 + 1] = 1.0;
          colors[i3 + 2] = 0.9 + t * 0.1;
        }

        // Converge toward center as approaching transformer
        if (y < CONVERT_Y) {
          const converge = Math.max(0, Math.min(1, (CONVERT_Y - y) / (CONVERT_Y - SERVER_TOP_Y)));
          positions[i3] *= (1 - converge * 0.03);
          positions[i3 + 2] *= (1 - converge * 0.03);

          // Spawn number sprite at conversion
          if (rainStates[i].phase === 'sand' && y < CONVERT_Y) {
            rainStates[i].phase = 'number';
            spawnNumberSprite(positions[i3], y, positions[i3 + 2]);
          }
        }

        // Kill particle when absorbed into server
        if (y < SERVER_TOP_Y - 2) {
          rainStates[i].active = false;
          positions[i3 + 1] = -999;

          // Trigger transformer glow
          triggerLayerGlow(0);
        }
      }

      rainParticles.geometry.attributes.position.needsUpdate = true;
      rainParticles.geometry.attributes.color.needsUpdate = true;
    }

    // ---- Number sprites ----
    function spawnNumberSprite(x, y, z) {
      for (let i = 0; i < NUMBER_COUNT; i++) {
        if (!numberSprites[i].userData.active) {
          const digit = Math.floor(Math.random() * 10);
          numberSprites[i].material.map = digitTextures[digit];
          numberSprites[i].material.opacity = 0.8;
          numberSprites[i].material.needsUpdate = true;
          numberSprites[i].position.set(x, y, z);
          numberSprites[i].userData.active = true;
          numberSprites[i].userData.velocity = 3 + Math.random() * 4;
          numberSprites[i].userData.targetX = (Math.random() - 0.5) * 4;
          return;
        }
      }
    }

    function updateNumbers(dt) {
      for (let i = 0; i < NUMBER_COUNT; i++) {
        const sprite = numberSprites[i];
        if (!sprite.userData.active) continue;

        sprite.userData.velocity += dt * 5;
        sprite.position.y -= sprite.userData.velocity * dt;

        // Converge toward center
        sprite.position.x += (sprite.userData.targetX - sprite.position.x) * dt * 2;
        sprite.position.z *= (1 - dt * 1.5);

        // Fade as approaching server
        if (sprite.position.y < SERVER_TOP_Y + 3) {
          sprite.material.opacity *= 0.95;
        }

        // Kill when absorbed
        if (sprite.position.y < SERVER_TOP_Y - 1 || sprite.material.opacity < 0.05) {
          sprite.userData.active = false;
          sprite.position.y = -999;
          sprite.material.opacity = 0;
        }
      }
    }

    // ---- Transformer glow ----
    let layerGlowQueue = [];

    function triggerLayerGlow(layerIndex) {
      if (transformerLayers[layerIndex]) {
        transformerLayers[layerIndex].glow = 1.0;

        // Cascade to next layer with delay
        if (layerIndex < transformerLayers.length - 1) {
          setTimeout(() => triggerLayerGlow(layerIndex + 1), 120);
        }
      }
    }

    function updateTransformerGlow(elapsed) {
      for (const layer of transformerLayers) {
        if (layer.glow > 0) {
          layer.glow *= 0.94; // decay
          if (layer.glow < 0.01) layer.glow = 0;
        }

        const o = layer.baseOpacity + layer.glow * 0.4;
        layer.mesh.material.opacity = o;
        layer.edges.material.opacity = layer.edgeBaseOpacity + layer.glow * 0.5;
      }

      // Subtle idle pulse on the server
      const pulse = Math.sin(elapsed * 2) * 0.02;
      for (const layer of transformerLayers) {
        layer.mesh.material.opacity += pulse;
      }
    }

    // ---- Conversion plane pulse ----
    function updateConversionPlane(elapsed) {
      conversionPlane.material.opacity = 0.1 + Math.sin(elapsed * 3) * 0.05;
    }

    // ---- Output particles ----
    function updateOutput(elapsed) {
      const positions = outputParticles.geometry.attributes.position.array;

      for (let i = 0; i < positions.length; i += 3) {
        positions[i + 1] -= 0.01;
        // Slow outward spiral
        const angle = elapsed * 0.3 + i;
        positions[i] += Math.cos(angle) * 0.002;
        positions[i + 2] += Math.sin(angle) * 0.002;

        // Reset when too far below
        if (positions[i + 1] < SERVER_BOTTOM_Y - 10) {
          const a = Math.random() * Math.PI * 2;
          const r = Math.random() * 3;
          positions[i] = Math.cos(a) * r;
          positions[i + 1] = SERVER_BOTTOM_Y - 2;
          positions[i + 2] = Math.sin(a) * r;
        }
      }
      outputParticles.geometry.attributes.position.needsUpdate = true;

      // Pulse opacity
      outputParticles.material.opacity = 0.3 + Math.sin(elapsed * 1.5) * 0.15;
    }

    // ============================================================
    //  RESIZE
    // ============================================================
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
